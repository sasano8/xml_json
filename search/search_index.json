{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"index jsl = json + s expression + xml json is a first value. Nodes can be expressed like xml or s-expressions. example These codes are roughly equivalent. Not fully compatible, but can convert structures to each other. jsl xml SXML jsonlogic JSONML @values( \"text1\" @values(\"text2\") \"text3\" ) <values> text1 <values> text2 </values> text3 </values> (values (value \"text1\") (values (value \"text2\")) (value \"text3\") ) {\"values\": [ \"text1, {\"values\": \"text2\"}, \"text3\" ]} [\"values\", [\"value\", \"text1\"], [\"values\", [\"value\", \"text2\"]], [\"value\", \"text3\"] ] node chain supports chaining of nodes, Supports node chaining and achieves beautiful node representation. Binary tree representation will be cleaner. jsl(use chain) jsl(no use chain) 1 :@add(2) :@add(3) @add( @add( 1 2 ) 3 ) # \u578b\u306b\u3059\u308b\u304b/\u30ad\u30fc\u30d0\u30ea\u30e5\u30fc\u306b\u3059\u308b\u304b @node( name: aaa asdf: asd ) # \u69cb\u6587\u3092\u5206\u3051\u308b @node( elem_type = 1 @shape( @dim( dim_value = 1 ) ) ) t1 <- @task(5) t2 <- @task(5) t3 <- @task(5) t4 <- @task(5) all = @task{\"name\": \"tasks1\"}( t1 t2 t3 ):@task{\"name\": \"tasks2\"}( t4 t5 t6 ) Create a simple DSL. def add(a, b): return Value(a.value + b.value) transformer = Transformer({\"add\": add}) tree = parser.parse(\"1:@add(2):@add(3)\") result = transformer.evalute(tree[0]) assert result == 6 statements = { \"from\": From, \"join\": Join, \"where\": Where, \"groupby\": GroupBy, \"having\": Having, \"orderby\": OrderBy, \"select\": Select } expressions = { \"+\": add, \"-\": minus } identifiers = { } functions = { } parser = Schema( name=\"myschema\", nodes=statements, expressions=expressions, identifiers=identifiers, functions=functions, case_sensitive=True, allow_unkown_identifiers=True, allow_unkown_functions=True, allow_param=True, allow_type={None, int, str, float, bool, list, dict} ) parser.parse(\"\"\" @from(u = users) :@join(g = groups, @(u.id == g.id)) :@where(@(u.id, g.id)) \"\"\")","title":"introduction"},{"location":"#index","text":"jsl = json + s expression + xml json is a first value. Nodes can be expressed like xml or s-expressions.","title":"index"},{"location":"#example","text":"These codes are roughly equivalent. Not fully compatible, but can convert structures to each other. jsl xml SXML jsonlogic JSONML @values( \"text1\" @values(\"text2\") \"text3\" ) <values> text1 <values> text2 </values> text3 </values> (values (value \"text1\") (values (value \"text2\")) (value \"text3\") ) {\"values\": [ \"text1, {\"values\": \"text2\"}, \"text3\" ]} [\"values\", [\"value\", \"text1\"], [\"values\", [\"value\", \"text2\"]], [\"value\", \"text3\"] ]","title":"example"},{"location":"#node-chain","text":"supports chaining of nodes, Supports node chaining and achieves beautiful node representation. Binary tree representation will be cleaner. jsl(use chain) jsl(no use chain) 1 :@add(2) :@add(3) @add( @add( 1 2 ) 3 ) # \u578b\u306b\u3059\u308b\u304b/\u30ad\u30fc\u30d0\u30ea\u30e5\u30fc\u306b\u3059\u308b\u304b @node( name: aaa asdf: asd ) # \u69cb\u6587\u3092\u5206\u3051\u308b @node( elem_type = 1 @shape( @dim( dim_value = 1 ) ) ) t1 <- @task(5) t2 <- @task(5) t3 <- @task(5) t4 <- @task(5) all = @task{\"name\": \"tasks1\"}( t1 t2 t3 ):@task{\"name\": \"tasks2\"}( t4 t5 t6 )","title":"node chain"},{"location":"#create-a-simple-dsl","text":"def add(a, b): return Value(a.value + b.value) transformer = Transformer({\"add\": add}) tree = parser.parse(\"1:@add(2):@add(3)\") result = transformer.evalute(tree[0]) assert result == 6 statements = { \"from\": From, \"join\": Join, \"where\": Where, \"groupby\": GroupBy, \"having\": Having, \"orderby\": OrderBy, \"select\": Select } expressions = { \"+\": add, \"-\": minus } identifiers = { } functions = { } parser = Schema( name=\"myschema\", nodes=statements, expressions=expressions, identifiers=identifiers, functions=functions, case_sensitive=True, allow_unkown_identifiers=True, allow_unkown_functions=True, allow_param=True, allow_type={None, int, str, float, bool, list, dict} ) parser.parse(\"\"\" @from(u = users) :@join(g = groups, @(u.id == g.id)) :@where(@(u.id, g.id)) \"\"\")","title":"Create a simple DSL."},{"location":"graph/","text":"graph","title":"graph"},{"location":"graph/#graph","text":"","title":"graph"},{"location":"node/","text":"node","title":"node"},{"location":"node/#node","text":"","title":"node"},{"location":"sql/","text":"sql","title":"sql"},{"location":"sql/#sql","text":"","title":"sql"},{"location":"syntax/","text":"syntax","title":"syntax"},{"location":"syntax/#syntax","text":"","title":"syntax"},{"location":"tutorial/","text":"tutorial","title":"tutorial"},{"location":"tutorial/#tutorial","text":"","title":"tutorial"}]}